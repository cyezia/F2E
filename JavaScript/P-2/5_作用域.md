# 作用域

## 对象

- 函数也是一种对象类型 引用类型 引用值

- 对象 -> 有些属性使我们无法访问的 -> JS引擎内部固有的隐式属性

## [[scope]]

- 1、函数创建时，生成的一个JS内部的隐式属性

- 2、函数存储作用域链的容器

  作用域链里面存储的是 AO GO

  AO，函数的执行期上下文

  GO，全局的执行期上下文

  函数执行完成以后，AO是要销毁的

  AO是一个即时的存储容器

## 例子1

- function a( ){

      function b(){}
      var a = 1; 
  }

  var c = 3;

  a( );

### 过程

### 1、当全局在执行的时候，首先生成了GO（函数还未被执行时）

- GO = {
  
  a: function a()

  c: 3

  }

### 2、当函数被定义时

- 系统生成[[scope]]属性，[[scope]]保存该函数的作用域链

- 该作用域链的第0位存储当前环境下的全局执行期上下文GO

- GO里存储全局下的所有对象，其中包含函数a和全局变量c

### 3、当函数被执行的前一刻，生成AO，排在GO的上面（没被执行时，只有GO）

- 作用域链的顶端（第0位）存储a函数生成的函数执行期上下文AO，同时第1位存储GO

- 查找变量是到函数a存储的作用域链中，从顶端开始依次向下查找

  例如：本例中要打印a的时候，先从自身的AO里找有没有a，有的话打印；如果自身的AO里没有a，才自上而下去GO里找

- AO = {
  
  a: 1

  b: function b()

  }

## 例子2 接例子1

function a( ){

      function b(){

        var b = 2;
      }
      var a = 1; 

      b();
  }

  var c = 3;

  a( );

### 4、当a函数在执行时，b函数被定义

- 当外层函数被执行的时候，内层函数被定义

- 当b函数未被执行之前，它的作用域链和a函数被执行期的作用域链一模一样（因为b函数的环境是在a函数上面）

- b函数的环境在a函数上，所以当a函数被执行的时候，b函数被定义；a函数环境在全局上，当全局在运行的时候a函数被定义

### 5、当b函数被执行的前一刻

- 生成b函数的[[scope]]，存储b函数的作用域链

- 顶端第0位存储b函数的AO，a函数的AO和全局的GO依次向下排列

- AO = {

  b: 2

  }

### 6、当b函数被执行结束后

- b函数的AO被销毁，回归被定义时的状态

### 7、当a函数被执行结束时

- a函数的AO被销毁的同时，b函数的[[scope]]也将不存在，a函数回归被定义时的状态

## 总结

- 每一个函数的作用域链里一定都有GO

- 一个函数都有自己的AO和一个全局的GO，AO排在GO前面

- 当函数被定义时，形成作用域[[scope]]、作用域链scope chain、GO放进作用域链里，在函数被执行时生成自己的AO
